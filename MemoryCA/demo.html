<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Memory CA with Rule Visualizer</title>
    <style>
        body {
            font-family: sans-serif;
            background: #f9f9f9;
            margin: 0;
            padding: 1rem;
            /*display: flex;*/
            flex-direction: column;
            /*align-items: center;*/
        }

        .canvas-container {
            position: relative;
            width: 1272px;
            height: 632px;
            margin-top: 20px;
        }

        #imageCanvas, #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

    </style>
</head>
<body>
<canvas id="c" width="400" height="400"></canvas>
<br><br>
<button id="reset_state">Reset State</button>
<button id="reset_CA">Reset CA Rule</button>
<br><br>
Add your own CA rule:
<input type="text" id="rule_name" placeholder="Rule Name">
<input type="text" id="rule_code" placeholder="512-bit Binary Code">
<button id="add_rule">Add Rule</button>

<br>

Current Rule:
<label id="current_rule" style="
  display: inline-block;
  width: 400px;
  font-size: 10px;
  padding: 4px;
  border: 1px solid #ccc;
  background-color: #f9f9f9;
  font-family: monospace;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;">
  This is a readonly-looking label
</label>

<div class="canvas-container">
    <canvas id="imageCanvas" width="953" height="474"></canvas>
    <canvas id="overlayCanvas" width="953" height="474"></canvas>
</div>

<script src="swissgl.js"></script>
<script src="dat.gui.min.js"></script>
</body>
</html>

<script>
    const imageCanvas = document.getElementById('imageCanvas');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const imageCtx = imageCanvas.getContext('2d');
    const overlayCtx = overlayCanvas.getContext('2d');

    const cols = 32;
    const rows = 16;
    const tileSize = 24;
    const padding = 6;

    const baseImage = new Image();
    baseImage.src = '512n_small.png';
    baseImage.onload = () => {
        imageCtx.drawImage(baseImage, 0, 0);
    };

    function drawOverlay(rule) {
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        overlayCtx.font = '16px monospace';
        overlayCtx.textAlign = 'center';
        overlayCtx.textBaseline = 'middle';

        for (let i = 0; i < 512; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const bit = rule[i];

            const x = col * (tileSize + padding);

            const y = row * (tileSize + padding);

            overlayCtx.fillStyle = bit === '1' ? 'rgba(0, 255, 0, 0.25)' : 'rgba(255, 0, 0, 0.25)';
            overlayCtx.fillRect(x, y, tileSize, tileSize);
        }
    }

    overlayCanvas.addEventListener('dblclick', (e) => {
        const rect = overlayCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const col = Math.floor(x / (tileSize + padding));
        const row = Math.floor(y / (tileSize + padding));

        if (col >= 0 && col < cols && row >= 0 && row < rows) {
            const index = row * cols + col;
            let code = CA.code;
            if (code[index] === '1') {
                code = code.substring(0, index) + '0' + code.substring(index + 1);
            } else {
                code = code.substring(0, index) + '1' + code.substring(index + 1);
            }
            load_CA(code);
        }
    });
</script>

<script>
    const canvas = document.getElementById('c');
    // create WebGL2 context end SwissGL
    const glsl = SwissGL(canvas);
    const gui = new dat.GUI();

    let rule_gui;
    let lastDrawTime = 0;

    // Add functionality for adding a new CA rule
    // Add a text box for the name of the rule and a text box for the 512 binary code
    // Do this in html below the canvas


    let CAs;
    let CA = null;
    let CA_state;
    let frame_count = 0;

    const params = {
        rule: "rule502",
        grid_size: 100,
        run_ca: true,
        // adaptive_steps: true,
        steps_per_frame: -1,

    };

    const uniforms = {
        init_bit: 0,
        brush_bit: 1,
        // init_bit: 1,
        noise_prob: 0.1,
        noise_bias: 0.0,
        update_prob: 1.0,
        brush_size: 0.1,

        mouse_x: 0.0,
        mouse_y: 0.0,
        mouse_down: false,


    };

    gui.add(params, 'grid_size', 40, 200).onChange(reset_state);
    gui.add(params, 'run_ca');
    gui.add(params, "steps_per_frame",
        {
            "1/60x": -4, "1/30x": -3, "1/10x": -2, "1/3x": -1, "1x": 0,
            "2x": 1, "4x": 2, "8x": 3, "16x": 4,
        }
    )
    // gui.add(params, "adaptive_steps").onChange((value) => {
    //     if (value) {
    //         params.steps_per_frame = Math.min(256, Math.max(1, Math.floor(1 / uniforms.update_prob)));
    //     } else {
    //         params.steps_per_frame = 1;
    //     }
    // });

    gui.add(uniforms, 'init_bit', {"0": 0, "1": 1, "Random": -1}).onChange(reset_state);
    gui.add(uniforms, 'brush_bit', {"0": 0, "1": 1, "Random": -1});

    gui.add(uniforms, 'noise_prob', 0.0, 1.0, 0.001);
    gui.add(uniforms, 'noise_bias', -1.0, 1.0, 0.001);
    gui.add(uniforms, 'update_prob', 0.001, 1.0, 0.001).onChange((value) => {
            if (params.adaptive_steps) {
                params.steps_per_frame = Math.min(256, Math.max(1, Math.floor(1 / value)));
            }
        }
    );
    gui.add(uniforms, 'brush_size', 0.01, 0.5);

    async function init() {
        const response = await fetch("ca_rules.json");
        CAs = await response.json();
        rule_gui = gui.add(params, 'rule', Object.keys(CAs)).onChange((value) => {
            CA = load_CA(CAs[value].code);
        });
        CA = load_CA(CAs[params.rule].code);
        reset_state();
        render();

    }

    init();

    // Add functionality to add a new CA rule
    document.getElementById('add_rule').addEventListener('click', () => {
        const rule_name = document.getElementById('rule_name').value;
        const rule_code = document.getElementById('rule_code').value.replace(/\s/g, "");
        if (rule_name && rule_code && rule_code.length === 512 && /^[01]+$/.test(rule_code)) {
            CAs[rule_name] = {name: rule_name, code: rule_code};
            // Modify the existing gui rule without adding a new element to the gui
            gui.remove(rule_gui);
            rule_gui = gui.add(params, 'rule', Object.keys(CAs)).onChange((value) => {
                CA = load_CA(CAs[value].code);
            });
            rule_gui.setValue(rule_name);
            CA = load_CA(CAs[rule_name].code);
        } else {
            alert("Please enter a valid rule name and a 512-bit binary code.");
        }
    });


    function load_CA(code) {
        binary_code = Float32Array.from(code, (c) => c === '1' ? 1.0 : 0.0)
        CA = {
            code: code,
            binary_code: binary_code,
            rule_bits: glsl({}, {
                size: [1, 512],
                format: "r32f",
                story: 1,
                tag: "rule",
                data: binary_code
            }),
        }
        drawOverlay(code);
        document.getElementById('current_rule').innerText = code;
        return CA;
    }

    function brush() {
        glsl({
            ...uniforms,
            seed: Math.random() * 5132,
            FP: `
                float d = distance(UV, vec2(mouse_x, mouse_y));
                if (d < brush_size) {
                    if (brush_bit == -1.0) {
                        float b = hash(ivec3(I, seed)).x;
                        FOut = vec4(b < 0.5 ? 1.0: 0.0);
                    } else if (brush_bit == 1.0) {
                        FOut = vec4(1);
                    } else {
                        FOut = vec4(0);
                    }
                } else {
                    FOut = Src(I);
                }
            `
        }, CA_state);
    }

    function reset_CA() {
        CA = load_CA(CAs[params.rule].code);
    }

    function reset_state() {
        CA_state = glsl({
            seed: Math.random() * 1000, ...uniforms,
            FP: `
                if (init_bit == -1.0) {
                    float b = hash(ivec3(I, seed)).x;
                    FOut = vec4(b < 0.5 ? 1.0: 0.0);
                } else if (init_bit == 1.0) {
                    FOut = vec4(1);
                } else {
                    FOut = vec4(0);
                }
            `
        }, {size: [params.grid_size, params.grid_size], format: 'r16f', story: 2, tag: 'state'});
    }


    // Reset Button
    document.getElementById('reset_state').addEventListener('click', () => {
        reset_state();
    });

    document.getElementById('reset_CA').addEventListener('click', () => {
        reset_CA();
    });


    // Mouse click
    canvas.addEventListener('mousedown', (e) => {
        e.preventDefault();
        if (e.button === 0) { // left click
            uniforms.mouse_down = true;
        }
    });
    canvas.addEventListener('mouseup', (e) => {
        e.preventDefault();
        if (e.button === 0) { // left click
            uniforms.mouse_down = false;
        }
    });
    canvas.addEventListener('mousemove', (e) => {
        e.preventDefault();
        uniforms.mouse_x = e.offsetX / canvas.width;
        uniforms.mouse_y = 1.0 - e.offsetY / canvas.height;
        if (uniforms.mouse_down) {
            brush();
        }
    });

    // Do the same for touch
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        uniforms.mouse_down = true;
    });
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        uniforms.mouse_down = false;
    });
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        uniforms.mouse_x = touch.clientX / canvas.width;
        uniforms.mouse_y = 1.0 - touch.clientY / canvas.height;
        if (uniforms.mouse_down) {
            brush();
        }
    });


    function step(t) {
        if (!params.run_ca) return;

        glsl({
            ...uniforms,
            rule: CA.rule_bits[0],
            seed: t + Math.random() * 6523,
            FP: `
                float s = Src(I).x;
                float p = 1.0;
                float res = 0.0;
                bool update_flag = hash(ivec3(I, seed)).x < update_prob;

                if (!update_flag) {
                    FOut = vec4(s);
                    return;
                }

                bool noise_flag = hash(ivec3(I, seed + 1231.0)).x < noise_prob;
                if (noise_flag) {
                    bool bias_flag = (hash(ivec3(I, seed + 7861.0)).x - 0.5) * 2.0 < noise_bias;
                    if (bias_flag) {
                        FOut = vec4(1.0);
                    } else  {
                        FOut = vec4(0.0);
                    }
                } else {
                    for (int i = -1; i < 2; i++) {
                        for (int j = -1; j < 2; j++) {
                            ivec2 pos = (I + ivec2(i,j)+ViewSize)%ViewSize;
                            res += Src(pos).x * p;
                            p *= 2.0;
                        }
                    }
                    float s_next = rule(ivec2(0, int(res))).x;
                    FOut = vec4(s_next);
                }
            `
        }, CA_state);

    }


    function render(t) {
        if (!CA) return;

        frame_count++;
        let spf = params.steps_per_frame;
        let steps = 1;
        if (spf <= 0) {
            const skip = [1, 3, 10, 30, 60][-spf]
            steps = (frame_count % skip) ? 0 : 1;
        } else {
            steps = [1, 2, 4, 8, 16][spf]
        }

        for (let i = 0; i < steps; i++) {
            step(t);
        }
        glsl({
            state: CA_state[0].nearest,
            FP: `vec4(vec3(state(UV).x)*0.6+0.2,1)`
        });
        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>